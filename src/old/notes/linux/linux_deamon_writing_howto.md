~~~~~
보통 이런건 고마운 분이 번역해 주셔서 보곤했는데, 이번 문서는 번역된것이 없어서 분량도 적고 해서 한번 해 봤습니다.
2004 년 약간은 오래되기도 하였지만 데몬을 이해하는데 조금이나마 도움이 되었으면 하는 바램입니다.

제가 접한 영어문서는
http://www.netzmafia.de/skripten/unix/linux-daemon-howto.html
에서 보실 수 있으시고
따로 번역한 파일을 본 페이지에 첨부하였습니다. 내용은 아래와 같습니다.


데몬을 배우면서 그냥 번역해봤습니다.
약간은 어색할지도 모르지만 양해바랍니다.
date : 2010-02-21 - by netPyoung
~~~~~

Linux Daemon Writing HOWTO
===========================

v1.0, May 2004 이 문서는 Linux상에서 GCC를 이용하여 어떻게 daemon을 작성하는지 보여줍니다. 이 문서를 이용하기 위해선 Linux에 관한 지식과 C와의 친밀감이 필요합니다. 이 HOWTO의 저작권은 BSD License하에 [Devin Watson]에게 있습니다.
------------------------------------------

1. 도입: Damon이란 무엇일까요?

2. 시작하기 앞서

3. 여러분의 Damon 구상

    3.1 이것이 어떻게 돌아가는 것일까요?
    3.2 얼마나 많이 상호작용이 일어날까요? 

4. 기본 Daemon 구조

    4.1 부모 Process나누기
    4.2 File Mode Mask (Umask)를 바꾸기
    4.3 쓰기위해 Log파일 열기
    4.4 고유 Session ID (SID)생성하기
    4.5 작업 디렉토리 바꾸기
    4.6 기본 파일 디스크립터 닫기 

5. Daemon 코드 작성하기

    5.1 초기화
    5.2 커다란 반복 

6. 모두 모아서 넣기

    6.1 Sample완성 

## 1. 도입: Damon이란 무엇일까요?

Daemon(혹은 service)는 유저 상호작용이 적거나 혹은 없이 자율적으로 돌아가도록 구상된 background process입니다. Apache web server http daemon(httpd)는 daemon의 이러한 하나의 예 입니다. 이것은 특정 포트에 대한 수신을 background상태에서 기다리고, 요청의 종류에 따라 page들을 제공하거나 스크립트를 진행을 합니다.

Linux에서 daemon만들기는 주어진 조건안에서 특별한 규칙모음을 이용합니다. 어떻게 그들이 일하는지에 대한 지식은 여러분들에게 daemon이 Linux 유저 공간에서 동작하는지 이해하는데 도움을 줄것이고, 또한 kernel에게 요청하는 작업도 할수 있습니다. 사실, 몇몇 daemon들은 외부 컨트롤러보드나, 프린터들, PDA들과 같은 하드웨어 장치에서 일하는 kernel module들과 상호작용합니다. 그들은 믿지못할 유연성과 힘을 주는 Linux를 구성하고 있는 빌딩 블록중 하나입니다.

이 HOWTO를 통하여, 매우 간단한 daemon을 C를 통해 만들어 볼것입니다. 저희와 함께 가다보면, 더 많은 코드들이 추가될것이고, 데몬이 발생하거나 동작하는데 필요한 작업 순서도 보여드릴 것입니다.

## 2. 시작하기 앞서

우선 첫번째로, 여러분은, daemon을 개발하기 위해, 여러분의 Linux머신에 다음과 같은 package들이 설치되어야 합니다 :

    GCC 3.2.2 혹은 상위버전
    Linux 개발 헤더들과 라이브러리들

만약 여러분의 시스템에 이것들이 설치되어있지 않았다면(싫더라도 확인해봅니다), 여러분들은 이 HOWTO의 예제를 개발하기 위해 그것들이 필요할 것입니다. 여러분들이 가진 GCC버전이 무엇인지 알아내기 위해서는, 이것을 사용합니다. :

            gcc --version


## 3. 여러분의 Damon 구상

### 3.1 이것이 어떻게 돌아가는 것일까요?

데몬은 어떤 한가지 일을 수행하고, 그것을 잘 해냅니다. 그것은 대다수의 domain들안의 수백개의 메일박스를 관리하는 복잡한것일수도 있고, 또는 리포트를 작성하거나 관리자에게 메일을 보내기 위해 sendmail을 호출하는 것일 수 도 있습니다.

어찌됐든지 간에, 여러분들은 데몬이 어떤일을 할것인지에 관한 좋은 계획이 필요합니다. 이것이 여러분들이 작성하거나 그렇지 않은 다른 데몬들과 상호작용하게 된다면, 다른것을 고려해 보는것이 좋습니다.

### 3.2 얼마나 많이 상호작용이 일어날까요?

데몬은 터미널을 통해 직접적으로 유저와 소통할수 없습니다. 사실, 데몬은 직접적으로 모든 유저와 소통 할수 없습니다. 모든 의사소통은, GTK+ GUI와 같은 복잡할수도 있고, signal set처럼 단순한 인터페이스의(여러분이 그렇게 했든 혹은 그렇지 않든) 일부를 통합니다.


## 4. 기본 Daemon 구조

데몬이 시작되었을때, 이것은 이것의 실제 작업을 준비하기 위해, 낮은 계층에서 해야할 일이 있습니다. 이것이 일어나는 몇몇 단계들 입니다 :

    부모 프로세스를 나눕니다.
    file mode mask (umask)를 바꿉니다.
    쓰기 위한 log를 엽니다.
    고유한 Session ID (SID)를 생성합니다.
    현제 작업 디렉토리를 안전한 장소로 바꿉니다.
    표준 파일 디스크립터를 닫습니다.
    실제 데몬 코드로 들어갑니다.

### 4.1 부모 Process나누기

데몬은 시스템 그자체나 터미널의 유저 또는 스크립트에 의해 시작되어집니다 이것이 시작할때, 프로세스는 시스템에서 다른 실행가능한것들과 똑같습니다. 이것을 실제로 스스로 움직이도록 만들려면, 실제 코드가 작동되어지는 자식 프로세스를 만들어야 합니다. 이것은 forking이라 알려졌고, 이것은 fork() 함수를 이용합니다.

            pid_t pid;

            /* 부모 프로세스를 나눕니다. */       
            pid = fork();
            if (pid < 0) {
                    exit(EXIT_FAILURE);
            }
            /* 만약 좋은 PID를 얻으면, 
               부모 프로세스를 종료시킬수 있습니다.. */
            if (pid > 0) {
                    exit(EXIT_SUCCESS);
            }

fork()호출 하자마자 error체크를 알립니다. 데몬이 작성할때, 우리는 가능한 방어적인 코드를 가져야합니다. 사실, 데몬의 전체 코드중 상당한 분량이 아무것도 아닌 오류검사로 이루어졌습니다.

fork() 함수는 자식 프로세스의 프로세스id(0이 아닌 PID)나, 실패시 -1을 반환합니다. 만약 프로세스가 자식을 fork하지 못한다면, 데몬은 여기서 소멸됩니다.

만약 fork()로부터 PID를 얻어오는게 성공하면, 부모 프로세스는 우아하게 종료되어야 합니다. 전에 이 과정을 보지 못했던 사람에게는 이것이 이상하게 보일 수도 있습니다. 그러나 forking으로, 자식 프로세스는 코드 안에서 빠져 나와서 계속 실행을 수행합니다.

### 4.2 File Mode Mask (Umask)를 바꾸기

데몬으로 다른 어떤 파일(log를 포함하여)을 작성할 것이라면, 그것들이 제대로 쓰여지거나 읽혀지기 위해 file mode maskt(umask)은 안전하게 바뀌어져야 합니다. 이것은 커맨드 라인으로 부터 실행되는 umask와 유사하고, 여기서 우리는 이것을 프로그래밍 할것입니다. 저희는 이것을 완성시키기 위해 umask()함수를 이용할 수 있습니다.

            pid_t pid, sid;
            
            /* 부모프로세스를 나눕니다. */
            pid = fork();
            if (pid < 0) {
                    /* 실패 로그를 남깁니다(가능하면 syslog를 사용합니다) */
                    exit(EXIT_FAILURE);
            }
            /* 만약 좋은 PID를 얻으면, 
               부모 프로세스를 종료시킬수 있습니다. */
            if (pid > 0) {
                    exit(EXIT_SUCCESS);
            }

            /* file mode mask를 바꿉니다. */
            umask(0);
            

umask를 0으로 설정 하면, 우리는 데몬에 의해 파일을 생성할수 있는 충분한 접근권을 가질 수 있습니다. 단지 이번 경우에 여러분은 파일시스템상 파일에 접근할수 있고, 만일 여러분이 어떤 파일을 사용할 계획이 없다면, 여기에 있는 umaks를 아무거나로 설정해도 괜찮을 것입니다.,

### 4.3 쓰기위해 Log파일 열기

이번 부분은 선택적이고, 여러분이 시스템에서 쓰기를 위하여 log파일을 열때 권장되어 집니다. 이것은 아마도 여러분의 데몬에 대한 디버깅 정보를 찾아볼 수 있는 유일한 장소일 것입니다.

### 4.4 고유 Session ID (SID)생성하기

여기에서 자식 프로세스는, 순서대로 작동하도록 커널로부터 고유한 SID를 얻어야 합니다. 그렇지 않으면, 자식 프로세스는 시스템에서 고아가 되어 버립니다. 전 단락에서 선언된 pid_t 상태 또한 자식 프로세스를 위한 새로운 SID 생성하는것에 사용되어지기도 합니다. :

            pid_t pid, sid;
            
            /* 부모프로세스를 나눕니다*/
            pid = fork();
            if (pid < 0) {
                    exit(EXIT_FAILURE);
            }
            /* 만약 좋은 PID를 얻으면, 
               부모 프로세스를 종료시킬수 있습니다. */
            if (pid > 0) {
                    exit(EXIT_SUCCESS);
            }
            
            /* file mode mask를 바꿉니다  */
            umask(0);
            
            /* 여기서 로그를 엽니다 */
            
            /* 자식 프로세스를 위해 새로운 SID를 생성합니다 */
            sid = setsid();
            if (sid < 0) {
                    /* 실패 로그를 남깁니다. */
                    exit(EXIT_FAILURE);
            }

재차, setsid()함수는 fork()와 같은 리턴타입을 가지고 있습니다. 우리는 여기서 이 함수가 만든 SID가 자식 프로세스를 위한것인지 보기 위해 같은 에러 처리 과정을 적용할 수 있습니다.

### 4.5 작업 디렉토리 바꾸기

현제 작업 디렉토리는 항상 그곳에 있는게 보장된 어떠한 장소로 바뀌어야만 합니다. 많은 리눅스 배포판들이 완벽하게는 표준 Linux 파일 시스템 상속관계를 따르지 않지만, 오직 root(/)만은 그곳에 있는게 보증되었습니다. 우리는 chdir()함수를 사용함으로 이것을 할 수 있습니다 :

            pid_t pid, sid;
            
            /* 부모프로세스를 나눕니다*/
            pid = fork();
            if (pid < 0) {
                    exit(EXIT_FAILURE);
            }
            /* 만약 좋은 PID를 얻으면, 
               부모 프로세스를 종료시킬수 있습니다. */
            if (pid > 0) {
                    exit(EXIT_SUCCESS);
            }
            
            /* file mode mask를 바꿉니다  */
            umask(0);
            
            /* 여기서 로그를 엽니다 */
            
            /* 자식 프로세스를 위해 새로운 SID를 생성합니다 */
            sid = setsid();
            if (sid < 0) {
                    /* 실패 로그를 남깁니다. */
                    exit(EXIT_FAILURE);
            }
            
            /* 현제 작업 디렉토리를 바꿉니다. */
            if ((chdir("/")) < 0) {
                    /* 여기서 실패 로그를 남깁니다. */
                    exit(EXIT_FAILURE);
            }
            

다시 한번, 여러분들은 방어적인 코딩이 일어난걸 볼 수 있습니다. chdir() 함수는 실패시 -1을 리턴하니, 데몬의 루트 디렉토리를 바꾼후에 확인을 합니다.

### 4.6 기본 파일 디스크립터 닫기

데몬 설정의 마지막 단계는 표준 파일 디스크립터(STDIN, STDOUT, STDERR)를 닫는 것입니다. 데몬이 터미널을 사용하지 못하기 때문에, 이 파일디스크립터들은 쓸모없고 잠재적인 보안 위험을 지니고 있습니다.

close()함수는 우리를 위해 이런것을 처리할 수 있습니다 :

            pid_t pid, sid;
            
            /* 부모프로세스를 나눕니다*/
            pid = fork();
            if (pid < 0) {
                    exit(EXIT_FAILURE);
            }
            /* 만약 좋은 PID를 얻으면, 
               부모 프로세스를 종료시킬수 있습니다. */
            if (pid > 0) {
                    exit(EXIT_SUCCESS);
            }
            
            /* file mode mask를 바꿉니다  */
            umask(0);
            
            /* 여기서 로그를 엽니다 */
            
            /* 자식 프로세스를 위해 새로운 SID를 생성합니다 */
            sid = setsid();
            if (sid < 0) {
                    /* 실패 로그를 남깁니다. */
                    exit(EXIT_FAILURE);
            }
            
            /* 현제 작업 디렉토리를 바꿉니다. */
            if ((chdir("/")) < 0) {
                    /* 여기서 실패 로그를 남깁니다. */
                    exit(EXIT_FAILURE);
            }
            
            /* 기본 파일 디스크립터를 닫습니다 */
            close(STDIN_FILENO);
            close(STDOUT_FILENO);
            close(STDERR_FILENO);

시스템 버전간의 상당한 이식성을 위하여, 상수로 정의된 파일 디스크립터를 고수하는 것은 좋은 생각 입니다.

## 5. Daemon 코드 작성하기

### 5.1 초기화

이 곳에 오기 까지, 여러분들은 리눅스에게 기본적으로 "내가 데몬이다" 라고 말했고, 지금 실제 데몬 코드를 작성할 시간이 되었습니다. 초기화는 여기서 첫번째 단계 입니다. 여기에 여러분의 데몬 작업을 설정할수 있는 다양한 함수들이 있지만, 여기서는 너무 깊게 나가지 않겠습니다.

여기서 중점은, 데몬안에서 어떤것을 초기화할때, 여기서 같은 방어적인 코딩 가이드라인을 적용한다는 것입니다. syslog나 여러분의 log를 작성할때 가능한 자세하게 합니다. 데몬 상태에 대한 사용가능한 충분한 정보가 없을 때 데몬을 디버깅하는것은 매우 어려울 수 있습니다.

###5.2 커다란 반복(The Big loop)

데몬의 주요 코드는 전통적으로 무한 루프안에 있습니다. 기술적으로는, 이것은 무한 루프가 아니지만, 다음과 같은 구조로 되어있습니다:

            pid_t pid, sid;
             
            /* 부모프로세스를 나눕니다*/
            pid = fork();
            if (pid < 0) {
                    exit(EXIT_FAILURE);
            }
            /* 만약 좋은 PID를 얻으면, 
               부모 프로세스를 종료시킬수 있습니다. */
            if (pid > 0) {
                    exit(EXIT_SUCCESS);
            }
            
            /* file mode mask를 바꿉니다  */
            umask(0);
            
            /* 여기서 로그를 엽니다 */
            
            /* 자식 프로세스를 위해 새로운 SID를 생성합니다 */
            sid = setsid();
            if (sid < 0) {
                    /* 실패 로그를 남깁니다. */
                    exit(EXIT_FAILURE);
            }
            
            /* 현제 작업 디렉토리를 바꿉니다. */
            if ((chdir("/")) < 0) {
                    /* 여기서 실패 로그를 남깁니다. */
                    exit(EXIT_FAILURE);
            }
            
            /* 기본 파일 디스크립터를 닫습니다 */
            close(STDIN_FILENO);
            close(STDOUT_FILENO);
            close(STDERR_FILENO);
            
            /* 여기서 특정-데몬의 초기화를 합니다. */
            
            /* 커다란 반복*/
            while (1) {
               /* 여기서 어떤 작업이 수행되고 ... */
               sleep(30); /*  30 초간 기다립니다 */
            }

보통, 이 전통적인 루프는, 영원히 종료하지 않을 조건과, 이것이 지정한 간격대로 실행하도록 sleep을 요청하는 while 루프입니다.

이것이 심장박동과 같다고 생각하면 : 여러분이 박동을 들을때, 이것은 몇가지 작업을 수행하고, 다음 박동 작업이 일어날때까지 기다립니다. 많은 데몬들은 이와 같은 방법론을 따릅니다.

## 6. 모두 모아서 넣기

### 6.1 Sample완성

아레 나열된 것은, 모든 필요한 설정과 실행과정을 보여주는 완성된 sample데몬입니다. 이것을 실행하려면, 간단히 gcc를 가지고 컴파일하고, 커맨드 라인에서 실행하면 됩니다. 종료하기 위해서는, 이것의 PID를 찾은후에 kill명령어를 사용합니다.

최소한 로그의 시작/정지/일시정지/죽음 상태를 보내는 것을 권장하고 , 저 또안 안에 syslog와 상호작용하기 위한 서술을 포함하여 올바른 것을 넣었습니다. 추가적으로 fopen()/fwrite()/fclose()함수를 여러분의 log에 사용할 수 있습니다.

``` c
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <syslog.h>
#include <string.h>

int main(void) {
            
        /* 저희의 프로세스ID와 세션 ID입니다 */
        pid_t pid, sid;
             
        /* 부모프로세스를 나눕니다*/
        pid = fork();
        if (pid < 0) {
                exit(EXIT_FAILURE);
        }
        /* 만약 좋은 PID를 얻으면, 
           부모 프로세스를 종료시킬수 있습니다. */
        if (pid > 0) {
                exit(EXIT_SUCCESS);
        }
            
        /* file mode mask를 바꿉니다  */
        umask(0);
            
        /* 여기서 로그를 엽니다 */
            
        /* 자식 프로세스를 위해 새로운 SID를 생성합니다 */
        sid = setsid();
        if (sid < 0) {
                /* 실패 로그를 남깁니다. */
                exit(EXIT_FAILURE);
        }
            
        /* 현제 작업 디렉토리를 바꿉니다. */
        if ((chdir("/")) < 0) {
                /* 여기서 실패 로그를 남깁니다. */
                exit(EXIT_FAILURE);
        }
            
        /* 기본 파일 디스크립터를 닫습니다 */
        close(STDIN_FILENO);
        close(STDOUT_FILENO);
        close(STDERR_FILENO);
            
        /* 여기서 특정-데몬의 초기화를 합니다. */
            
        /* 커다란 반복*/
        while (1) {
           /* 여기서 어떤 작업이 수행되고 ... */
           sleep(30); /*  30 초간 기다립니다 */
        }
   exit(EXIT_SUCCESS);
}
```
여기에서, 우리는 우리의 데몬을 작성하기 위해 이 뼈대(skeleton)를 사용할 수 있습니다. 여러분의 로깅과정(혹은 syslog 기능을 사용)을 추가하고, 방어적인 코드, 방어적인 코드, 방어적인 코드를 명심합니다!(code defensively, code defensively, code defensively!) 

 [Devin Watson]: mailto://dmwatson@comcast.net